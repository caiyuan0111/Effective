## 第二章 创建和销毁对象
### 第一条：考虑用静态工厂方法代替构造器
#### 优势
1. 静态工厂方法与构造器不同的一大优势在于，它们有名称
2. 优势二：不必要每次调用它们的时候都创建一个新对象
3. 优势三：它们可以返回原返回类型的任何子类型的对象
4. 优势四：在创建参数化类型实例的时候，它们使代码变得更加简洁

#### 缺点
1. 类如果不含公有或受保护的构造器，就不能被子类化
2. 它们与其他的静态方法实际上没有任何区别

### 第二条：遇到多构造器参数时要考虑用构建器

### 第三条：用私有构造器或者枚举类型强化Singleton属性

### 第四条：通过私有构造器强化不可实例化的能力

### 第五条：避免创建不必要的对象

### 第六条：消除过期的对象引用

### 第七条：避免使用终结方法

## 第三章 对于所有对象都通用的方法

### 第八条： 覆盖equals时请遵守通用约定

1. 类的每个实例本质上都是唯一的
2. 不关心类是否提供了”逻辑相等“的测试功能
3. 超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的
4. 类是私有的或是包级私有的，可以确定它的equals方法永远不会被调用

#### 实现高质量equals方法得到诀窍

1. 使用==操作符检查 “参数是否为这个对象的引用”。如果是，返回true
2. 使用instanceof操作符检查 “参数是否为正确的类型”。如果不是，返回false
3. 把参数转换成正确的类型
4. 对于该类中的每个 “关键”域，检查参数中的域是否与该对象中对应的域想匹配
5. 当你编写完成equals方法后，应问自己三个问题：它是否对称，是否传递，是否一致

#### 注意

1. 覆盖equals时总要覆盖hashCode
2. 不要企图让equals方法过于智能
3. 不要将equals声明中的Object对象替换为其他的类型

### 第九条：覆盖equals时总要覆盖hashCode

### 第十条：始终要覆盖toString

### 第十一条：谨慎地覆盖clone

### 第十二条：考虑实现Comparable接口

## 第四章 类和接口

### 第十三条：使类和成员的可访问性最小化

#### 成员的访问级别

1. 私有的（private）：只要声明该成员的顶层类内部才能访问
2. 包级私有的（package-private）：声明该成员的包内部的任何类都可以访问
3. 受保护的（protected）：声明该成员的类和子类都可以访问
4. 公有的（public）：在任何地方都可以访问该成员

### 第十四条：在公有类中使用访问方法而非公有域



